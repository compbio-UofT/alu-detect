#!/bin/bash
. $(which lib.alu-detect.sh)
set -x

NCPU="${NCPU:-20}"
export NGS_NAME="$1"
export REAL_CALLS="$2"
ORIG_FAKE_CALLS="$3"

# used to transfrom real<->fake coordinates
DELETIONS="${DELETIONS:-deletions.bed}"

# targets to look for
export TARGETS="${TARGETS:-targets.fake.bed}"
export TARGETS_IN_ALUS="${TARGETS_IN_ALUS:-targets.near-clear-alus.fake.bed}"

# alus in references
REAL_REF_ALUS="${REAL_REF_ALUS:-alus.real.bed}"
FAKE_REF_ALUS="${FAKE_REF_ALUS:-alus.fake.bed}"
CLEAR_FAKE_REF_ALUS="${CLEAR_FAKE_REF_ALUS:-clear-alus.fake.bed}"

# extra targets we don't care about (in fake coordinates)
BAD_TARGETS="${BAD_TARGETS:-targets.bad.fake.bed}"

# known alus (in real coordinates)
KNOWN_ALUS_OTHERS="${KNOWN_ALUS_OTHERS:-calls-elsewhere.bed}"

SAMPLE=${NGS_NAME%-*}
export KNOWN_ALUS=${KNOWN_ALUS:-../results-others/calls.$SAMPLE.bed}

# alus to compare against
export STANDARD_ALUS="${STANDARD_ALUS:-calls-standard.bed}"

# gen-file suffix
GF="${GF:-pgen}"


# step 1: clean up fake calls
export FAKE_CALLS=raw-calls.${NGS_NAME}.fake.clean.bed
if [ ! -r $FAKE_CALLS.$GF ]; then
  cat <<-EOF >$FAKE_CALLS.$GF
	#!/usr/bin/env gen-file
	##$ORIG_FAKE_CALLS $TARGETS $BAD_TARGETS $KNOWN_ALUS_OTHERS $DELETIONS
	{ intersectBed -u -s -a "$ORIG_FAKE_CALLS" -b "$TARGETS";
	  intersectBed -v -s -a "$ORIG_FAKE_CALLS" -b <(zc "$TARGETS" "$BAD_TARGETS" <(real-to-fake $DELETIONS $KNOWN_ALUS_OTHERS) | cut -f -6); } \
	  | sort -s -k 1,1 -k 2,2n
	EOF
  chmod a+x $FAKE_CALLS.$GF
fi
./$FAKE_CALLS.$GF -g || exit 1

# step 2: apply ref-alu-bp filter to clean fake calls
export FAKE_CALLS_REF_ALU_BP=raw-calls.${NGS_NAME}.fake.clean.ref-alu-bp.bed
if [ ! -r $FAKE_CALLS_REF_ALU_BP.$GF ]; then
  cat <<-EOF >$FAKE_CALLS_REF_ALU_BP.$GF
	#!/usr/bin/env gen-file
	##$FAKE_CALLS $FAKE_REF_ALUS
	filter-ref-alu-bp $FAKE_REF_ALUS $FAKE_CALLS
	EOF
  chmod a+x $FAKE_CALLS_REF_ALU_BP.$GF
fi
./$FAKE_CALLS_REF_ALU_BP.$GF -g || exit 1

# step 3: clean fake calls near alus
export FAKE_CALLS_NEAR_ALUS=raw-calls.${NGS_NAME}.fake.clean.near-alus.bed
if [ ! -r $FAKE_CALLS_NEAR_ALUS.$GF ]; then
  cat <<-EOF >$FAKE_CALLS_NEAR_ALUS.$GF
	#!//usr/bin/env gen-file
	##$FAKE_CALLS $CLEAR_FAKE_REF_ALUS $TARGETS $TARGETS_IN_ALUS

	# in 2 steps:
	# 1: pass through calls that detect targets near clear alus
	{ intersectBed -u -s -a $FAKE_CALLS -b $TARGETS_IN_ALUS;
	# 2: from the rest, remove calls (near clear alus) that detect other (nearby) targets
	  intersectBed -v -s -a $FAKE_CALLS -b $TARGETS | intersectBed -u -a - -b <(extend-bed 100 $CLEAR_FAKE_REF_ALUS); } \
	  | sort -s -k 1,1 -k 2,2n
	EOF
  chmod a+x $FAKE_CALLS_NEAR_ALUS.$GF
fi
./$FAKE_CALLS_NEAR_ALUS.$GF -g || exit 1

# step 4: apply ref-alu-bp filter to clean fake calls near alus
export FAKE_CALLS_NEAR_ALUS_REF_ALU_BP=raw-calls.${NGS_NAME}.fake.clean.near-alus.ref-alu-bp.bed
if [ ! -r $FAKE_CALLS_NEAR_ALUS_REF_ALU_BP.$GF ]; then
  cat <<-EOF >$FAKE_CALLS_NEAR_ALUS_REF_ALU_BP.$GF
	#!//usr/bin/env gen-file
	##$FAKE_CALLS_NEAR_ALUS $FAKE_REF_ALUS
	filter-ref-alu-bp $FAKE_REF_ALUS $FAKE_CALLS_NEAR_ALUS
	EOF
  chmod a+x $FAKE_CALLS_NEAR_ALUS_REF_ALU_BP.$GF
fi
./$FAKE_CALLS_NEAR_ALUS_REF_ALU_BP.$GF -g || exit 1

# step 5: apply ref-alu-bp filter to real calls
export REAL_CALLS_REF_ALU_BP=raw-calls.${NGS_NAME}.real.ref-alu-bp.bed
if [ ! -r $REAL_CALLS_REF_ALU_BP.$GF ]; then
  cat <<-EOF >$REAL_CALLS_REF_ALU_BP.$GF
	#!/usr/bin/env gen-file
	##$REAL_CALLS $REAL_REF_ALUS
	filter-ref-alu-bp $REAL_REF_ALUS $REAL_CALLS
	EOF
  chmod a+x $REAL_CALLS_REF_ALU_BP.$GF
fi
./$REAL_CALLS_REF_ALU_BP.$GF -g || exit 1


# step 6: try all filters, and adapt
export TABLE_FILTERS=table.${NGS_NAME}.csv

if [ ! -r $TABLE_FILTERS ]; then
    export WORK_DIR=table.${NGS_NAME}.dir/
    mkdir -p $WORK_DIR
    export NULL_VALS="${NULL_VALS:-$(seq -s " " 0 50 300)}"
    export CI_LEN_VALS="${CI_LEN_VALS:-$(seq -s " " 300 200 1100)}"
    export OUTPUT_FD=3
    LEN_MIN=${LEN_MIN:-150}
    LEN_MAX=${LEN_MAX:-290}
    SUPP_MIN=${SUPP_MIN:-5}
    SUPP_MAX=${SUPP_MAX:-30}
    LEN_SAFETY=50
    SUPP_SAFETY=5

    while true; do
	LOG_FILE=log.${NGS_NAME}.len${LEN_MIN}-${LEN_MAX}.supp${SUPP_MIN}-${SUPP_MAX}.txt
	export LEN_VALS="$(seq -s " " $LEN_MIN 10 $LEN_MAX)"
	export SUPP_VALS="$(seq -s " " $SUPP_MIN $SUPP_MAX)"
	make_note "trying len${LEN_MIN}-${LEN_MAX} supp${SUPP_MIN}-${SUPP_MAX}"

	run-filters.parallel "$NCPU" 3>>$TABLE_FILTERS >${WORK_DIR}$LOG_FILE 2>&1 || exit 1

	top_filter=($(get-top-filter $TABLE_FILTERS))
	if [ "${#top_filter[*]}" -eq 0 ]; then
	    if [ $SUPP_MAX -lt 30 ]; then
		SUPP_MAX=$(($SUPP_MAX + $SUPP_SAFETY))
		[ $SUPP_MAX -gt 30 ] && SUPP_MAX=30
		make_note "no suitable filters; increasing support"
		continue
	    else
		crash "no suitable filters found!"
	    fi
	fi

	make_note "top filter: ${top_filter[@]}"

	done=1
	[ $((${top_filter[0]} + $LEN_SAFETY)) -gt $LEN_MAX -a $LEN_MAX -lt 290 ] && done=
	[ $((${top_filter[0]} - $LEN_SAFETY)) -lt $LEN_MIN -a $LEN_MIN -gt 150 ] && done=
	[ $((${top_filter[1]} + $SUPP_SAFETY)) -gt $SUPP_MAX ] && done=
	[ $((${top_filter[1]} - $SUPP_SAFETY)) -lt $SUPP_MIN -a $SUPP_MIN -gt 5 ] && done=
	[ "$done" ] && break

	LEN_MAX=$((${top_filter[0]} + $LEN_SAFETY))
	[ $LEN_MAX -gt 290 ] && LEN_MAX=290
	LEN_MIN=$((${top_filter[0]} - $LEN_SAFETY))
	[ $LEN_MIN -lt 150 ] && LEN_MIN=150
	SUPP_MAX=$((${top_filter[1]} + $SUPP_SAFETY))
	SUPP_MIN=$((${top_filter[1]} - $SUPP_SAFETY))
	[ $SUPP_MIN -lt 5 ] && SUPP_MIN=5
    done
fi

# step 7: filter real calls based on top filter
FILTERED_REAL_CALLS=../results-us/calls.${NGS_NAME}.real.bed
if [ ! -r $FILTERED_REAL_CALLS.$GF ]; then
    cat <<-EOF >$FILTERED_REAL_CALLS.$GF
	#!/usr/bin/env gen-file
	##$(rel_path $REAL_CALLS ../results-us) ../simulation/$TABLE_FILTERS
	top_filter=(\$(get-top-filter ../simulation/$TABLE_FILTERS | cut -f -5))
	COMMAND="apply-filter \${top_filter[@]}"
	[ "\${top_filter[4]}" != /dev/null ] && COMMAND="\${COMMAND} | filter-ref-alu-bp $(rel_path $REAL_REF_ALUS ../results-us) -"
	eval \$COMMAND <$(rel_path $REAL_CALLS ../results-us) | sort -s -k 1,1 -k 2,2n
	EOF
    chmod a+x $FILTERED_REAL_CALLS.$GF
fi
./$FILTERED_REAL_CALLS.$GF -g

# step 8: filter fake calls based on top filter
FILTERED_FAKE_CALLS=../results-us/calls.${NGS_NAME}.fake.bed
if [ ! -r $FILTERED_FAKE_CALLS.$GF ]; then
    cat <<-EOF >$FILTERED_FAKE_CALLS.$GF
	#!/usr/bin/env gen-file
	##$(rel_path $FAKE_CALLS ../results-us) ../simulation/$TABLE_FILTERS
	top_filter=(\$(get-top-filter ../simulation/$TABLE_FILTERS | cut -f -5))
	COMMAND="apply-filter \${top_filter[@]}"
	[ "\${top_filter[4]}" != /dev/null ] && COMMAND="\${COMMAND} | filter-ref-alu-bp $(rel_path $FAKE_REF_ALUS ../results-us) -"
	eval \$COMMAND <$(rel_path $FAKE_CALLS ../results-us) | sort -s -k 1,1 -k 2,2n
	EOF
    chmod a+x $FILTERED_FAKE_CALLS.$GF
fi
./$FILTERED_FAKE_CALLS.$GF -g
