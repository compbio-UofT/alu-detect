#!/usr/bin/env python2.6+

import sys
import operator
import math
import argparse
import functools
from my import *
import my_sam as sam

good_mapping_cigar_ops = 'M=X'
good_mapping_max_nm_val = 2
good_mapping_min_as_frac = .9
good_mapping_min_mqv = 10
default_stop_count = 10000
drop_fraction = .001
default_rg = '00'

have_nm_field = -1
have_as_field = -1
max_as_val = 0

rg_dict = {}


def good_mapping(d):
    global have_nm_field, have_as_field, max_as_val

    ops = sam.parse_cigar_string(d['cigar'])
    for op in ops:
        if op[0] not in good_mapping_cigar_ops:
            note('discarding mapping of [%s]: bad cigar ops [%s]' % (d['name'], d['cigar']), 2)
            return False

    if have_nm_field < 0:
        if 'NM' in d:
            nm_val = d['NM']
            note('NM field detected', 1)
            have_nm_field = 1
        else:
            note('NM field absent', 1)
            have_nm_field = 0
    elif have_nm_field == 1:
        if 'NM' in d:
            nm_val = d['NM']
        else:
            note('NM field missing [%s]' % '\t'.join(m), 1)
            have_nm_field = 0
    if have_nm_field == 1 and nm_val > good_mapping_max_nm_val:
        note('discarding mapping of [%s]: bad NM value [%d]' % (d['name'], nm_val), 2)
        return False

    if have_as_field != 0 and len(rg_dict) > 1:
        have_as_field = 0
        note('2 or more read groups; disabling AS field', 1)

    if have_as_field < 0:
        if 'AS' in d:
            as_val = d['AS']
            note('AS field detected', 1)
            have_as_field = 1
        else:
            note('AS field absent', 1)
            have_as_field = 0
    elif have_as_field == 1:
        if 'AS' in d:
            as_val = d['AS']
        else:
            note('AS field missing [%s]' % '\t'.join(m), 1)
            have_as_field = 0
    if have_as_field == 1 and as_val < 0:
        note('AS field contains negative values, disabling', 1)
        have_as_field = 0
    if have_as_field == 1 and as_val > max_as_val:
        max_as_val = as_val
        note('new max AS value [%d]' % max_as_val, 1)
    if have_as_field == 1 and as_val < max_as_val * good_mapping_min_as_frac:
        note('discarding mapping of [%s]: bad AS value [%d]' % (d['name'], as_val), 2)
        return False

    if d['mqv'] < good_mapping_min_mqv:
        note('discarding mapping of [%s]: bad MQV [%d]' % (d['name'], d['mqv']), 2)
        return False

    return True

parser = argparse.ArgumentParser(description=sys.argv[0])
parser.add_argument('-v', '--verbose', action='append_const', const=1, default=[], dest='verbose')
parser.add_argument('-c', '--stop-count', action='store', type=int,
                    default=default_stop_count, dest='stop_count')
parser.add_argument('-f', '--ignore-flags', action='store_true', default=False, dest='ignore_flags')
parser.add_argument('--cid-parser', action='store', dest='cid_parser')
parser.add_argument('input', action='store', nargs='?')
args = parser.parse_args()
set_log_level(len(args.verbose))
note('using stop count: [%d]' % args.stop_count, 1)
ignore_flags = args.ignore_flags

if args.cid_parser:
    _temp = __import__(args.cid_parser, globals(), locals(), ['cid_parser'])
    cid_parser = _temp.cid_parser
else:
    cid_parser = sam.default_cid_parser
mapping_parser = functools.partial(sam.mapping_parser, cid_parser=cid_parser)

if args.input:
    in_fd = gzopen(args.input)
else:
    in_fd = gzopen('-')


for ms in sam.get_mapping_set_gen(in_fd, mapping_parser=mapping_parser):
    if len(ms) > 2:
        crash('found mapping set with more than 2 mappings: ' + str(ms))

    if len(ms) == 2:
        if ('RG' in ms[0]) != ('RG' in ms[1]):
            crash('RG found in some but not all reads of the same pair: ' + str(ms))
        if 'RG' in ms[0] and (ms[0]['RG'] != ms[1]['RG']):
            crash('reads in the same pair are in different read groups: ' + str(ms))

    if 'RG' in ms[0]:
        rg_string = ms[0]['RG']
    else:
        rg_string = default_rg

    if rg_string not in rg_dict:
        note(rg_string + ': new read group')
        rgd = {}
        rgd['idx'] = len(rg_dict)
        rgd['detected_unpaired'] = False
        rgd['detected_paired'] = False
        rg_dict[rg_string] = rgd
    rgd = rg_dict[rg_string]

    if ms[0]['paired']:
        if not rgd['detected_paired']:
            note(rg_string + ': found paired reads')
            rgd['detected_paired'] = True
            rgd['detected_st_diff'] = -1
            rgd['count_st_diff'] = [0, 0]
            rgd['delta'] = []
            rgd['r1_len'] = -1
            rgd['r2_len'] = -1
            rgd['detected_delta_min'] = -1
            rgd['detected_delta_max'] = -1
            rgd['detected_delta_mean'] = -1
            rgd['detected_delta_stddev'] = -1
    else:
        if not rgd['detected_unpaired']:
            note(rg_string + ': found unpaired reads')
            rgd['detected_unpaired'] = True
            rgd['unpaired_count'] = 0
            rgd['min_r_len'] = -1
            rgd['max_r_len'] = -1

    done = True
    for s in rg_dict:
        if ((rg_dict[s]['detected_paired']
             and (rg_dict[s]['detected_st_diff'] == -1 or rg_dict[s]['detected_delta_min'] == -1))
            or (rg_dict[s]['detected_unpaired']
                and rg_dict[s]['unpaired_count'] < args.stop_count)):
            done = False
            break
    if done:
        break

    if ms[0]['paired']:
        if len(ms) == 1:
            #crash('did not find pair for read: ' + str(ms))
            note('discarding single mapping of a read pair: ' + str(ms), 2)
            continue
        if not ms[1]['paired']:
            crash('inconsistent pairing flags in a pair: ' + str(ms))
    else:
        if len(ms) == 2:
            crash('found more than one mapping for an unpaired read: ' + str(ms))

    if not ms[0]['paired']:
        if rgd['unpaired_count'] >= args.stop_count:
            continue
        rgd['unpaired_count'] += 1
        if 'len' in ms[0]:
            if rgd['max_r_len'] >= 0:
                rgd['max_r_len'] = max(rgd['max_r_len'], ms[0]['len'])
            else:
                rgd['max_r_len'] = ms[0]['len']
            if rgd['min_r_len'] >= 0:
                rgd['min_r_len'] = min(rgd['min_r_len'], ms[0]['len'])
            else:
                rgd['min_r_len'] = ms[0]['len']
        continue

    # paired:
    if rgd['detected_st_diff'] != -1 and rgd['detected_delta_min'] != -1:
        continue

    # if either is not mapped, ignore
    if not ms[0]['mapped'] or not ms[1]['mapped']:
        note('discarding unmapped clone: ' + str(ms), 2)
        continue

    # only paired mappings with both reads paired make it here
    if (not ignore_flags
        and (not sam.all_properly_aligned(ms[0]) or not sam.all_properly_aligned(ms[1]))):
        note('discarding mappings: not all properly aligned: ' + str(ms), 2)
        continue

    if not good_mapping(ms[0]) or not good_mapping(ms[1]):
        continue

    if ms[0]['chr'] != ms[1]['chr']:
        note('discarding mappings: different chromosomes: ' + str(ms), 2)
        continue

    if not ignore_flags and not sam.check_pair_flags(ms):
        crash('bad flags: ' + str(ms))

    # paired mapping on the same chromosome
    st_diff = int(sam.is_reversed(ms[0]) != sam.is_reversed(ms[1]))
    if rgd['detected_st_diff'] == -1:
        rgd['count_st_diff'][st_diff] += 1
        note(rg_string + ': using map set for st_diff: ' + str(ms), 2)
        if rgd['count_st_diff'][0] + rgd['count_st_diff'][1] < args.stop_count:
            continue
        if rgd['count_st_diff'][0] > 10 * rgd['count_st_diff'][1]:
            rgd['detected_st_diff'] = 0
        elif rgd['count_st_diff'][1] > 10 * rgd['count_st_diff'][0]:
            rgd['detected_st_diff'] = 1
        else:
            crash('could not detect st_diff, neither dominates: [%d] vs [%d]'
                 % (rgd['count_st_diff'][0], rgd['count_st_diff'][1]))
        note(rg_string + ': detected st_diff: [%d]' % rgd['detected_st_diff'], 1)

    if st_diff != rgd['detected_st_diff']:
        note('discarding mappings: bad st_diff ' + str(ms), 2)
        continue

    note(rg_string + ': using map set for insert distribution: ' + str(ms), 2)
    if ms[0]['nip'] == 1:
        ms = ms[::-1]
    if rgd['r1_len'] >= 0:
        rgd['r1_len'] = max(rgd['r1_len'], ms[0]['len'])
    else:
        rgd['r1_len'] = ms[0]['len']
    if rgd['r2_len'] >= 0:
        rgd['r2_len'] = max(rgd['r2_len'], ms[1]['len'])
    else:
        rgd['r2_len'] = ms[1]['len']
    pos = [sam.get_pos(ms[0])[0], sam.get_pos(ms[1])[0]]
    fivep = [pos[0][ms[0]['st']], pos[1][ms[1]['st']]]
    delta = (fivep[1] - fivep[0]) * [1, -1][ms[0]['st']]
    rgd['delta'].append(delta)

    if len(rgd['delta']) >= args.stop_count:
        l = rgd['delta']
        note('len(l)=%d' % len(l), 1)
        l.sort()
        drop_count = int(args.stop_count * drop_fraction)
        l = l[drop_count:-drop_count]
        rgd['detected_delta_min'] = l[0]
        note(rg_string + ': detected delta min [%d]' % rgd['detected_delta_min'], 1)
        rgd['detected_delta_max'] = l[-1]
        note(rg_string + 'detected delta max [%d]' % rgd['detected_delta_max'], 1)
        rgd['detected_delta_mean'] = sum(l)/len(l)
        note('detected delta mean [%d]' % rgd['detected_delta_mean'], 1)
        rgd['detected_delta_stddev'] = math.sqrt(
            sum(map(lambda x: x*x, l)) / (len(l) - 1)
            - (sum(l) * sum(l)) / (len(l) * (len(l) - 1)))
        note('detected delta stddev [%d]' % rgd['detected_delta_stddev'], 1)


fill = 2
while 2 * len(rg_dict) > 10**fill:
    fill += 1

idx = 0
for k in sorted(rg_dict):
    if rg_dict[k]['detected_paired']:
        s = str(idx)
        s = ('0' * (fill - len(s))) + s
        print ('%s\t%s\tpaired=1,st_diff=%d,min=%d,max=%d,mean=%d,stddev=%d,r1_len=%d,r2_len=%d' %
               (k + '_paired', s,
                rg_dict[k]['detected_st_diff'],
                rg_dict[k]['detected_delta_min'], rg_dict[k]['detected_delta_max'],
                rg_dict[k]['detected_delta_mean'], rg_dict[k]['detected_delta_stddev'],
                rg_dict[k]['r1_len'], rg_dict[k]['r2_len']))
        idx += 1
    if rg_dict[k]['detected_unpaired']:
        s = str(idx)
        s = ('0' * (fill - len(s))) + s
        print ('%s\t%s\tpaired=0,r1_len=%d,r2_len=%d' %
               (k + '_unpaired', s,
                rg_dict[k]['min_r_len'], rg_dict[k]['max_r_len']))
        idx += 1

gzclose(in_fd)
