#!/bin/bash
. lib.alu-detect.sh
set -eEux -o pipefail


#
# don't trust the user; check most settings
#
which samtools >/dev/null 2>&1 || crash "samtools not found"
which bowtie2 >/dev/null 2>&1 || crash "bowtie2 not found"
for suffix in .1.bt2 .2.bt2 .3.bt2 .4.bt2 .rev.1.bt2 .rev.2.bt2; do
    [ -r "$BOWTIE2_INDEX$suffix" ] || crash "bowtie2 index file missing: $BOWTIE2_INDEX$suffix"
done


TRIM_STEP=5
MIN_LEN=20
MIN_MQV=5

MAPPER_CMD="bowtie2-sort -x $BOWTIE2_INDEX -p $NCPU -U"

find_my_name_and_dir "${BASH_SOURCE[0]}"
make_temp_dir "$MY_NAME"
make_note "using TDIR=$TDIR"

if [ -f "$1" ] ; then
    READS_FILE="$1"
else
    READS_FILE="$TDIR"/reads.fq.gz
    make_note "copying reads to tmp..."
    $PV "$@" | zc | $ZIP >"$READS_FILE"
fi
make_note "using reads file: $READS_FILE"

PREV_STEP=0
CRT_STEP=1
CRT_TRIM=0
CRT_TRIM_SIDE=3p
SWITCH_SIDES=0

mkfifo "$TDIR"/pipe-3
mkfifo "$TDIR"/pipe-4
mkfifo "$TDIR"/pipe-5
mkfifo "$TDIR"/pipe-6
mkfifo "$TDIR"/pipe-7

while true ; do
    pids=()
    if [ $CRT_TRIM -eq 0 ] ; then
	make_note "preparing reads..."
	$PV "$READS_FILE" | zc | add-seq-to-read-name \
	    | fq-convert -v ofq=tfq | sed 's/\/[12]\t/\t/' \
	    | fq-convert -v ofq=fq >"$TDIR"/pipe-3 &
	pids+=($!)
    elif [ $SWITCH_SIDES -eq 1 ] ; then
	make_note "switching sides; extracting unmapped and badly mapped reads..."
	command="SORT_OPTIONS=\"-S 10G -s -t : -k 1,1n -k 2,2n\" merge-recursively"
	for f in "$TDIR"/bad-3p_*.sam.gz "$TDIR"/short-3p_*.sam.gz; do
	    command="$command <(zc $f)"
	done
	eval $command \
	    | cut -f 1 | get-seq-from-read-name -v ofq=fq \
	    | fq-trim-reads-relative -v trim_len_${CRT_TRIM_SIDE}=$TRIM_STEP >"$TDIR"/pipe-3 &
	pids+=($!)
    else
	make_note "processing previous stage..."
	$PV "$TDIR"/map_body_${PREV_STEP}.sam.gz \
	    | zc "$TDIR"/map_header_${PREV_STEP}.sam - \
	    | add-extra-sam-flags -N 4 -q $MIN_MQV -i 0 \
	    | filter-mappings -N 4 \
	      -f 0x1000:"$TDIR"/pipe-4 \
	      -f 0/0x1004:"$TDIR"/pipe-5 \
	      -f 0x4:\&1 \
	    | sam-to-fq \
	    | fq-trim-reads-relative -v trim_len_${CRT_TRIM_SIDE}=$TRIM_STEP >"$TDIR"/pipe-3 &
	pids+=($!)
	$ZIP <"$TDIR"/pipe-4 >>"$TDIR"/final-${CRT_TRIM_SIDE}_${PREV_STEP}.sam.gz &
	pids+=($!)
	$ZIP <"$TDIR"/pipe-5 >>"$TDIR"/bad-${CRT_TRIM_SIDE}_${PREV_STEP}.sam.gz &
	pids+=($!)
    fi

    # remove short reads
    fq-remove-short-reads <"$TDIR"/pipe-3 -v min_len=$MIN_LEN -v short_reads_fd=3 \
	3>"$TDIR"/pipe-6 | tee-p "$TDIR"/pipe-7 | $ZIP >"$TDIR"/reads_${CRT_STEP}.fq.gz &
    pids+=($!)
    id-to-unmapped-sam <"$TDIR"/pipe-6 | $ZIP >"$TDIR"/short-${CRT_TRIM_SIDE}_${CRT_STEP}.sam.gz &
    pids+=($!)
    fq-stats <"$TDIR"/pipe-7 >"$TDIR"/reads_${CRT_STEP}.stats &
    pids+=($!)

    #
    # sync at this point
    #
    i=0
    while [ $i -lt ${#pids[@]} ]; do
	wait ${pids[$i]}
	let i+=1
    done

    # clean up to keep space reasonable
    if [ $CRT_TRIM -ne 0 ]; then
	if [ $SWITCH_SIDES -eq 1 ]; then
	    rm "$TDIR"/bad-3p_*.sam.gz "$TDIR"/short-3p_*.sam.gz
	    SWITCH_SIDES=0
	else
	    rm "$TDIR"/map_body_${PREV_STEP}.sam.gz
	fi
    fi

    if [ $(head -n 1 "$TDIR"/reads_${CRT_STEP}.stats | cut -d " " -f 1) -eq 0 ] ; then
	if [ $CRT_TRIM_SIDE = 3p ] ; then
	    PREV_STEP=$CRT_STEP
	    CRT_STEP=$(($CRT_STEP + 1))
	    CRT_TRIM=$TRIM_STEP
	    CRT_TRIM_SIDE=5p
	    SWITCH_SIDES=1
	    make_note "done with 3p side, starting 5p side"
	    continue
	else
	    break
	fi
    fi

    make_note "step:$CRT_STEP	trim:$CRT_TRIM	trim_side:$CRT_TRIM_SIDE	reads left:$(head -n 1 "$TDIR"/reads_${CRT_STEP}.stats | cut -d " " -f 1)"

    # map current batch
    make_note "mapping current batch and sorting..."
    $PV "$TDIR"/reads_${CRT_STEP}.fq.gz | zc \
        | $MAPPER_CMD - \
        | tee-p >(sam-header >"$TDIR"/map_header_${CRT_STEP}.sam) \
	| sam-body | $ZIP >"$TDIR"/map_body_${CRT_STEP}.sam.gz
    rm "$TDIR"/reads_${CRT_STEP}.fq.gz

    PREV_STEP=$CRT_STEP
    CRT_STEP=$(($CRT_STEP + 1))
    CRT_TRIM=$(($CRT_TRIM + $TRIM_STEP))
done

cat "$TDIR"/map_header_1.sam

command="SORT_OPTIONS=\"-S 10G -s -t : -k 1,1n -k 2,2n\" merge-recursively"

for f in "$TDIR"/final-3p_*.sam.gz; do
    command="$command <(zc $f | sam-add-trim-len-to-cigar -v trim_side=3p)"
done

for f in "$TDIR"/final-5p_*.sam.gz; do
    command="$command <(zc $f | sam-add-trim-len-to-cigar -v trim_side=5p)"
done

for f in "$TDIR"/bad-5p_*.sam.gz; do
    command="$command <(zc $f | cut -f 1 | id-to-unmapped-sam)"
done

for f in "$TDIR"/short-5p_*.sam.gz; do
    command="$command <(zc $f)"
done

eval $command

rm -rf "$TDIR"
