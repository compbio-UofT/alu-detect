#!/bin/bash
[ "$BASE_DIR" ] ||
{
    echo "run this script through alu-detect wrapper" >&2
    exit 1
}
source lib.alu-detect.sh
set -eEu -o pipefail

usage () {
    echo "Use: $(basename $0) <ngs_name> <real_ref_name> <fake_ref_name> <real_ref_calls_bed> <fake_ref_calls_bed>"
}

if [ $# -ne 5 ]; then
    usage >&2
    exit
fi

export NGS_NAME=$1
real_ref_name=$2
fake_ref_name=$3
raw_real_calls=$4
raw_fake_calls=$5

set_real_and_fake_ref_var_names $real_ref_name $fake_ref_name
check_files_readable "$real_ref_fa" "$real_ref_fai" \
    "$real_ref_bt2_idx".{{1..4},rev.{1..2}}.bt2 "$real_ref_alus_bed"
check_files_readable "$fake_ref_fa" "$fake_ref_fai" \
    "$fake_ref_bt2_idx".{{1..4},rev.{1..2}}.bt2 "$fake_ref_alus_bed"


# check for deletions, targets, and known alus
deletions=$BASE_DIR/data/deletions.$real_ref_name.to.$fake_ref_name.bed
check_files_readable "$deletions"
targets=$BASE_DIR/data/targets.$fake_ref_name.bed
check_files_readable "$targets"
targets_bad=$BASE_DIR/data/targets.bad.$fake_ref_name.bed
[ -r "$targets_bad" ] || targets_bad=
known_novel_alus=$BASE_DIR/data/known-novel-alus.$real_ref_name.bed
[ -r "$known_novel_alus" ] || known_novel_alus=


START_STAGE=${START_STAGE:-1}
END_STAGE=${END_STAGE:-100}
make_note "using START_STAGE=$START_STAGE and END_STAGE=$END_STAGE"


# step 1: apply ref-alu-bp to real calls
STAGE_NUM=1
STAGE_NAME="apply ref-alu-bp to real calls"
filtered_real_calls=$NGS_NAME.$real_ref_name.calls.raw.ref-alu-bp.bed
INPUT_FILES="$raw_real_calls"
OUTPUT_FILES="$filtered_real_calls"
stage_command() {
    filter-ref-alu-bp "$real_ref_alus_bed" "$raw_real_calls" |
    sort -s -k 1,1 -k 2,2n >"$filtered_real_calls"
}
run_stage


# step 2: clean up fake calls, and apply ref-alu-bp to fake calls
STAGE_NUM=2
STAGE_NAME="clean up fake calls, and apply ref-alu-bp to fake calls"
filtered_fake_calls=$NGS_NAME.$fake_ref_name.calls.raw.ref-alu-bp.bed
INPUT_FILES="$raw_fake_calls"
OUTPUT_FILES="$filtered_fake_calls"
stage_command() {
    {
	intersectBed -u -s -a "$raw_fake_calls" -b "$targets"
	zc "$targets" \
	    <([ ! "$targets_bad" ] || exec zc "$targets_bad") \
	    <([ ! "$known_novel_alus" ] || exec real-to-fake "$deletions" "$known_novel_alus") |
	cut -f -6 |
	intersectBed -v -s -a "$raw_fake_calls" -b -
    } |
    filter-ref-alu-bp "$fake_ref_alus_bed" - |
    sort -s -k 1,1 -k 2,2n >"$filtered_fake_calls"
}
run_stage


# step 3: try various filters, adapting
STAGE_NUM=3
STAGE_NAME="try various filters, adapting"
table_filters=table.$NGS_NAME.csv
INPUT_FILES="$filtered_fake_calls $filtered_real_calls"
OUTPUT_FILES="$table_filters"
stage_command() {
    export WORK_DIR=table.$NGS_NAME.dir/
    mkdir -p $WORK_DIR
    export NULL_VALS=${NULL_VALS:-$(seq -s " " 0 50 300)}
    export CI_LEN_VALS=${CI_LEN_VALS:-$(seq -s " " 300 200 1100)}
    export OUTPUT_FD=3
    export CALLS_TRUTH_PAIRS="$filtered_fake_calls:$targets;$filtered_real_calls:$known_novel_alus"
    export CALLS_LIST="$filtered_fake_calls;$filtered_real_calls"
    export CALLS_FILTER_LIST=":filter-bp 1:filter-bp 2;:filter-bp 1:filter-bp 2"
    export TRUTH_LIST="$targets;$known_novel_alus"
    export TRUTH_LEN_LIST="$(wc -l <$targets);$(wc -l <$known_novel_alus)"

    abs_len_min=150
    abs_len_max=290
    abs_supp_min=5
    abs_supp_max=30
    len_safety=50
    len_step=10
    supp_safety=5
    supp_step=1

    len_min=${len_min:-$abs_len_min}
    len_max=${len_max:-$abs_len_max}
    supp_min=${supp_min:-$abs_supp_min}
    supp_max=${supp_max:-$abs_supp_max}

    while true; do
	log_file=log.${NGS_NAME}.len${len_min}-${len_max}.supp${supp_min}-${supp_max}.txt
	export LEN_VALS=$(seq -s " " $len_min $len_step $len_max)
	export SUPP_VALS=$(seq -s " " $supp_min $supp_step $supp_max)
	make_note "trying len${len_min}-${len_max} supp${supp_min}-${supp_max}"

	run-filters.parallel "$NCPU" 3>>$table_filters >${WORK_DIR}$log_file 2>&1

	top_filter=($(get-top-filter $table_filters))
	if [ "${#top_filter[*]}" -eq 0 ]; then
	    if [ $supp_max -lt $abs_supp_max ]; then
		let supp_max+=$supp_safety
		[ $supp_max -le $abs_supp_max ] || supp_max=$abs_supp_max
		make_note "no suitable filters; increasing support"
		continue
	    else
		make_note "no suitable filters and maximum support!"
		break
	    fi
	fi

	make_note "top filter: ${top_filter[@]}"

	done_here=1
	[ $len_max -ge $abs_len_max ] ||
	[ $((${top_filter[0]} + $len_safety)) -le $len_max ] || done_here=
	[ $len_min -le $abs_len_min ] ||
	[ $((${top_filter[0]} - $len_safety)) -ge $len_min ] || done_here=
	[ $((${top_filter[1]} + $supp_safety)) -le $supp_max ] || done_here=
	[ $supp_min -le $abs_supp_min ] ||
	[ $((${top_filter[1]} - $supp_safety)) -ge $supp_min ] || done_here=
	[ ! $done_here ] || break

	let len_max=${top_filter[0]}+$len_safety
	[ $len_max -le $abs_len_max ] || len_max=$abs_len_max
	let len_min=${top_filter[0]}-$len_safety
	[ $len_min -ge $abs_len_min ] || len_min=$abs_len_min
	let supp_max=${top_filter[1]}+$supp_safety
	let supp_min=${top_filter[1]}-$supp_safety
	[ $supp_min -ge $abs_supp_min ] || supp_min=$abs_supp_min
    done
}
run_stage


# step 4: filter real calls based on top filter
STAGE_NUM=4
STAGE_NAME="filter real calls based on top filter"
real_calls=$NGS_NAME.$real_ref_name.calls.filtered.bed
INPUT_FILES="$filtered_real_calls $table_filters"
OUTPUT_FILES="$real_calls"
stage_command() {
    apply-filter $(get-top-filter "$table_filters") <"$filtered_real_calls" >"$real_calls"
}
run_stage


# step 5: filter fake calls based on top filter
STAGE_NUM=5
STAGE_NAME="filter fake calls based on top filter"
fake_calls=$NGS_NAME.$fake_ref_name.calls.filtered.bed
INPUT_FILES="$filtered_fake_calls $table_filters"
OUTPUT_FILES="$fake_calls"
stage_command() {
    apply-filter $(get-top-filter "$table_filters") <"$filtered_fake_calls" >"$fake_calls"
}
run_stage
