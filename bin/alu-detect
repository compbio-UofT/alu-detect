#!/bin/bash
. lib.alu-detect.sh
set -eEux -o pipefail

[ ! -e /proc/$$/fd/3 ] || crash "fd 3 needs to be closed"


find_my_name_and_dir "${BASH_SOURCE[0]}"
BASE_DIR=$(dirname $MY_DIR)
make_note "$MY_NAME v$(cat $BASE_DIR/VERSION) (git:$($BASE_DIR/get_git_version)) installed in $MY_DIR"

NGS_NAME=$1
REF_NAME=$2
prefix=$NGS_NAME.$REF_NAME

GLOBAL_SETTINGS=$BASE_DIR/settings/global
. "$GLOBAL_SETTINGS" || crash "missing global settings file: $GLOBAL_SETTINGS"
REF_SETTINGS=$BASE_DIR/settings/ref.$REF_NAME
. "$REF_SETTINGS" 2>/dev/null || crash "missing reference settings file: $REF_SETTINGS"


#
# don't trust the user; check most settings
#
(which python >/dev/null 2>&1 && [ "$(python --version 2>&1 | cut -d '.' -f 2)" -ge 6 ]) \
    || crash "python2.6+ not found"
which samtools >/dev/null 2>&1 || crash "samtools not found"
which intersectBed >/dev/null 2>&1 || crash "intersectBed not found"
which bowtie2 >/dev/null 2>&1 || crash "bowtie2 not found"
which gmapper-ls >/dev/null 2>&1 || crash "gmapper not found"
[[ "$AWKPATH" =~ $BASE_DIR/bin ]] || crash "AWKPATH not set properly"
[ -r "$ALU_ALL_FA" ] || crash "Alu consensus sequences missing from: $ALU_ALL_FA"
[ -r "$ALU_NO_POLYA_FA" ] || crash "masked Alu consensus sequences missing from: $ALU_NO_POLYA_FA"

[ -r "$REF_FA" ] || crash "reference fasta file missing: $REF_FA"
[ -r "$CHROMINFO" ] || crash "chrominfo file missing: $CHROMINFO"
for suffix in .1.bt2 .2.bt2 .3.bt2 .4.bt2 .rev.1.bt2 .rev.2.bt2; do
    [ -r "$BOWTIE2_INDEX$suffix" ] || crash "bowtie2 index file missing: $BOWTIE2_INDEX$suffix"
done
[ -r "$ALUS_BED" ] || crash "reference alu annotations missing: $ALUS_BED"


make_note "using NCPU=$NCPU"
START_STAGE=${START_STAGE:-0}
END_STAGE=${END_STAGE:-100}
make_note "using START_STAGE=$START_STAGE and END_STAGE=$END_STAGE"


if [ $START_STAGE -lt 3 ]; then
    # need original mappings
    ORIG_UNPAIRED_READS=${ORIG_UNPAIRED_READS:-}
    ORIG_PAIRED_READS=${ORIG_PAIRED_READS:-}
    ORIG_READS_1=${ORIG_READS_1:-}
    ORIG_READS_2=${ORIG_READS_2:-}
    ORIG_READ_GROUPS=${ORIG_READ_GROUPS:-}
    ORIG_MAPPINGS=${ORIG_MAPPINGS:-}
    make_note "using unpaired reads file(s): [$ORIG_UNPAIRED_READS]"
    make_note "using paired reads file(s): [$ORIG_PAIRED_READS]"
    make_note "using reads_1 file(s): [$ORIG_READS_1]"
    make_note "using reads_2 file(s): [$ORIG_READS_2]"
    make_note "using reads group(s): [$ORIG_READ_GROUPS]"
    make_note "using mapping file(s): [$ORIG_MAPPINGS]"
    make_note "dropping pairs mapped to different chromosomes: $(([ ${DROP_PAIRS_DIFF_CHR:-} ] && echo "yes") || echo "no")"

    orig_unpaired_reads=($(echo $ORIG_UNPAIRED_READS))
    orig_paired_reads=($(echo $ORIG_PAIRED_READS))
    orig_reads_1=($(echo $ORIG_READS_1))
    orig_reads_2=($(echo $ORIG_READS_2))
    orig_read_groups=($(echo $ORIG_READ_GROUPS))
    orig_mappings=($(echo $ORIG_MAPPINGS))

    have_unpaired_reads=0
    if [[ ${#orig_unpaired_reads[@]} -ne 0 &&
	${#orig_unpaired_reads[@]} -eq ${#orig_read_groups[@]} ]]; then
	have_unpaired_reads=1
	make_note "found unpaired reads"
    fi

    have_paired_reads_single=0
    if [[ ${#orig_paired_reads[@]} -ne 0 &&
	${#orig_paired_reads[@]} -eq ${#orig_read_groups[@]} ]]; then
	have_paired_reads_single=1
	make_note "found paired reads in single file(s)"
    fi

    have_paired_reads_double=0
    if [[ ${#orig_reads_1[@]} -ne 0 &&
	${#orig_reads_1[@]} -eq ${#orig_read_groups[@]} &&
	${#orig_reads_2[@]} -eq ${#orig_read_groups[@]} ]]; then
	have_paired_reads_double=1
	make_note "found paired reads in double file(s)"
    fi

    have_mappings=0
    if [ ${#orig_mappings[@]} -ne 0 ]; then
	have_mappings=1
	make_note "found mappings"
    fi

    let n_inputs=$have_unpaired_reads+$have_paired_reads_single+$have_paired_reads_double+$have_mappings 1
    [ $n_inputs -ge 1 ] || crash "No inputs specified"
    [ $n_inputs -le 1 ] || crash "Too many inputs specified"

    if [ $have_mappings = 0 ]; then
	make_note "given reads only; need to map them"
	INPUT_PHRED=${INPUT_PHRED:-}
	[ ! $INPUT_PHRED ] || make_note "using global input PHRED: [$INPUT_PHRED]"
	rm -f $prefix.initial.pairing

	i=0
	while [ $i -lt ${#orig_read_groups[@]} ]; do
	    export RGID=${orig_read_groups[$i]}
	    rg_pairing=$prefix.pairing.$RGID.$i
	    rg_mapping=$prefix.map.$RGID.$i

	    if [ $have_unpaired_reads = 1 ]; then

		if [ $INPUT_PHRED ]; then
		    input_phred_rg=$INPUT_PHRED
		else
		    input_phred_rg=$(fq-detect-phred ${orig_unpaired_reads[$i]})
		    make_note "detected PHRED+$input_phred_rg for read group $RGID"
		fi

		STAGE_NUM=0.$i
		STAGE_NAME="original mappings for unpaired read group: $RGID"
		INPUT_FILES="${orig_unpaired_reads[$i]}"
		OUTPUT_FILES="$rg_mapping.sam.gz"
		STATS_FILE=
		stage_command() {
		    $PV ${orig_unpaired_reads[$i]} |
		    zc |
		    bowtie2 -x $BOWTIE2_INDEX -U - \
			--phred$input_phred_rg -p $NCPU --rg-id $RGID 2>$rg_mapping.log |
		    $ZIP >$rg_mapping.sam.gz
		}
		run_stage

	    elif [ $have_paired_reads_single = 1 ]; then

                if [ $INPUT_PHRED ]; then
                    input_phred_rg=$INPUT_PHRED
                else
                    input_phred_rg=$(fq-detect-phred ${orig_paired_reads[$i]})
		    make_note "detected PHRED+$input_phred_rg for read group $RGID"
                fi

		STAGE_NUM=0.$i.1
		STAGE_NAME="detect pairing for paired read group: $RGID"
		INPUT_FILES="${orig_paired_reads[$i]}"
		OUTPUT_FILES="$rg_pairing"
		STATS_FILE=
		stage_command() {
		    INPUT_PHRED=$input_phred_rg fq-detect-pairing ${orig_paired_reads[$i]} |
		    cut -f 3 >$rg_pairing
		}
		run_stage

		STAGE_NUM=0.$i.2
		STAGE_NAME="mapping for paired read group: $RGID"
		INPUT_FILES="${orig_paired_reads[$i]} $rg_pairing"
		OUTPUT_FILES="$rg_mapping.sam.gz"
		STATS_FILE=$rg_mapping.stats
		stage_command() {
		    $PV ${orig_paired_reads[$i]} |
		    zc |
		    split-file 4:- 4:/dev/null |
		    bowtie2 -x $BOWTIE2_INDEX \
			-1 - -2 <(zc ${orig_paired_reads[$i]} | split-file 4:/dev/null 4:-) \
			$(get-bowtie-pairing -p $(cat $rg_pairing)) \
			--phred$input_phred_rg -p $NCPU --rg-id $RGID 2>$rg_mapping.log |
		    $ZIP >$rg_mapping.sam.gz
		}
		stage_stats_command() {
		    $PV $rg_mapping.sam.gz |
		    samtools view -Su - |
		    samtools flagstat -
		}
		run_stage

	    else

                if [ $INPUT_PHRED ]; then
                    input_phred_rg=$INPUT_PHRED
                else
                    input_phred_rg=$(fq-detect-phred ${orig_reads_1[$i]})
		    make_note "detected PHRED+$input_phred_rg for read group $RGID"
                fi

		STAGE_NUM=0.$i.1
		STAGE_NAME="detect pairing for paired read group: $RGID"
		INPUT_FILES="${orig_reads_1[$i]} ${orig_reads_2[$i]}"
		OUTPUT_FILES="$rg_pairing"
		STATS_FILE=
		stage_command() {
		    INPUT_PHRED=$input_phred_rg fq-detect-pairing \
			${orig_reads_1[$i]} ${orig_reads_2[$i]} |
		    cut -f 3 >$rg_pairing
		}
		run_stage

		STAGE_NUM=0.$i.2
		STAGE_NAME="mapping for paired read group: $RGID"
		INPUT_FILES="${orig_reads_1[$i]} ${orig_reads_2[$i]} $rg_pairing"
		OUTPUT_FILES="$rg_mapping.sam.gz"
		STATS_FILE=$rg_mapping.stats
		stage_command() {
		    $PV ${orig_reads_1[$i]} |
		    zc |
		    bowtie2 -x $BOWTIE2_INDEX \
			-1 - -2 <(exec zc ${orig_reads_2[$i]}) \
			$(get-bowtie-pairing -p $(cat $rg_pairing)) \
			--phred$input_phred_rg -p $NCPU --rg-id $RGID 2>$rg_mapping.log |
		    $ZIP >$rg_mapping.sam.gz
		}
		stage_stats_command() {
		    $PV $rg_mapping.sam.gz |
		    samtools view -Su - |
		    samtools flagstat -
		}
		run_stage

	    fi

	    ORIG_MAPPINGS="$ORIG_MAPPINGS $rg_mapping.sam.gz"
	    let i+=1
	done
	orig_mappings=($(echo $ORIG_MAPPINGS))
	orig_read_groups=()
    fi
else
    ORIG_MAPPINGS=
fi


get_orig_mappings() {
    file=${orig_mappings[$1]}
    [ -r $file ] || crash "$file: file not found"
    rg=${orig_read_groups[$1]:-}
    command="$PV $file"
    if (set +o pipefail; zc $file | head -n 1 | cut -c -3 | grep -q "BAM"); then
	command="$command | samtools view -h -"
    elif (set +o pipefail; file $file | grep -q gzip); then
	command="$command | $UNZIP"
    fi
    if [ ${DROP_PAIRS_DIFF_CHR:-} ]; then
	command="$command | tawk 'substr(\$1,1,1)==\"@\" || and(\$2,0x1)==0 || and(\$2,0x4)==1 || and(\$2,0x8)==1 || \$7==\"=\"'" 
    fi
    if [ ${add_dummy_pairs:-} ]; then
	command="$command | add-dummy-pairs"
    fi
    if (set +o pipefail; zc $file | head -n 1 | grep -q "coordinate") || [ "${RSORT:-}" ]; then
	command="$command | sam-rsort"
    fi
    if [ "$rg" ]; then
	command="$command | add-default-rg -r \"$rg\" -s \"$NGS_NAME\""
    fi
    make_note "command to get mappings: $command"
    eval $command
#    (set +e +o pipefail; eval $command | add-default-rg $rg || true)
}


#
# Stage 1: detect pairing information in mappings
#
STAGE_NUM=1
STAGE_NAME="detect pairing information"
pairing_file=$prefix.pairing
INPUT_FILES="$ORIG_MAPPINGS"
OUTPUT_FILES="$pairing_file"
STATS_FILE=
stage_command() {
    rm -f $pairing_file.tmp
    i=0
    while [ $i -lt ${#orig_mappings[@]} ]; do
	no_sigpipe get_orig_mappings $i |
	detect-pairing -f >>$pairing_file.tmp
	let i+=1
    done
    sed 's/\(^.*stddev=\([0-9]*\),.*$\)/\1\t\2/' <$pairing_file.tmp |
    sort -s -k 1,1 -k 4,4n |
    cut -f 1-3 |
    tawk 'BEGIN{last=""} {if ($1!=last) print; last=$1}' >$pairing_file.tmp.uniq
    tawk -v n=$(wc -l <$pairing_file.tmp.uniq) \
	'{$2=NR-1; while (length($2)<length(n-1)) $2="0" $2; print}' \
	<$pairing_file.tmp.uniq >$pairing_file
}
run_stage

grep -q "paired=" $pairing_file || crash "could not determine pairing information"


#
# Stage 2: Extract discordant reads and rename them
#
# Input: mappings, reads
# Output: reads unmapped and reads mapped unpaired
#
STAGE_NUM=2
STAGE_NAME="extract discordant reads"
reads_to_remap=$prefix.reads.to_remap
INPUT_FILES="$ORIG_MAPPINGS"
if [ "${SINGLE_READS_TO_REMAP:-}" ]; then
    OUTPUT_FILES="$reads_to_remap.fq.gz"
else
    OUTPUT_FILES=$(for rg in $(cut -f 1 $pairing_file); do echo "$reads_to_remap.$rg."{1,2}".fq.gz"; done)
fi
STATS_FILE=
stage_command () {
    i=0
    while [ $i -lt ${#orig_mappings[@]} ]; do
	add_dummy_pairs=1 get_orig_mappings $i |
	add-extra-sam-flags -N 4 -l $pairing_file |
	filter-mappings -N 4 -l $pairing_file 3>/dev/null \
	    -f 0x10000,0x10000:\&3 \
	    \
	    -f 0x10000,0/0x6004:\&3 \
	    -f 0x10000,0:\&1 \
	    -f 0/0x6004,0x10000:\&3 \
	    -f 0,0x10000:\&1 \
	    \
	    -f 0x4,0:\&1 \
	    -f 0,0x4:\&1 \
	    -f 0/0x8000,0:\&1 \
	    -f 0/0x6000,/0x6000:\&3 \
	    -f 0,0:\&1 |
	sam-to-fq -s -l $pairing_file
	let i+=1
    done |
    fq-trim-illumina-reads -v input_phred=33 |
    fq-remove-short-paired-reads |
    fq-rename-paired-reads-with-len |
    {
	if [ "${SINGLE_READS_TO_REMAP:-}" ]; then
	    $ZIP >$reads_to_remap.fq.gz
	else
	    fq-convert -v ofq=tfq |
	    sed 's/^\(.........\([0-9]\+\):\([12]\):\)/\2.\3\t\1/' |
	    split-file-by-field -r --prefix $reads_to_remap. --suffix .fq.gz \
		--cmd "fq-convert -v ofq=fq | $ZIP" \
		-d <(tawk '{print $2 ".1", $1 ".1"; print $2 ".2", $1 ".2";}' \
			<$pairing_file)
	fi
    }
}
run_stage


#
# Stage 4: Progressive mapping
#
# Input: reads to remap
# Output: mappings to reference, possibly trimmed
#
STAGE_NUM=4
STAGE_NAME="progressive mapping to reference"
mappings_to_reference=$prefix.map.to_reference
if [ "${SINGLE_READS_TO_REMAP:-}" ]; then
    INPUT_FILES="$reads_to_remap.fq.gz"
else
    INPUT_FILES=$(for rg in $(cut -f 1 $pairing_file); do echo "$reads_to_remap.$rg."{1,2}".fq.gz"; done)
fi 
OUTPUT_FILES="$mappings_to_reference.sam.gz"
STATS_FILE=
stage_command() {
    if [ "${SINGLE_READS_TO_REMAP:-}" ]; then
	progressive-mapping "$reads_to_remap.fq.gz"
    else
	progressive-mapping "$reads_to_remap.*.1.fq.gz" "$reads_to_remap.*.2.fq.gz"
    fi |
    tee >($ZIP >$mappings_to_reference.sam.gz) |
    samtools view -Su - |
    samtools flagstat - >$mappings_to_reference.stats
}
run_stage


#
# Stage 5: Clean reference mappings
#
# Input: mappings to reference
# Output: same, removing clones which are mapped as pairs
#
STAGE_NUM=5
STAGE_NAME="clean up reference mappings: remove unpaired and paired well; add orig reads and quals"
mappings_clean_to_reference=$prefix.map.clean_to_reference
INPUT_FILES="$mappings_to_reference.sam.gz"
OUTPUT_FILES="$mappings_clean_to_reference.sam.gz $mappings_clean_to_reference.stats"
STATS_FILE=
stage_command() {
    $PV $mappings_to_reference.sam.gz |
    add-extra-sam-flags -N 4 -l $pairing_file -P |
    filter-mappings -N 4 -l $pairing_file -P 3>/dev/null \
	-f 0x10000,0x10000:\&3 \
	-f 0x10000,0x3000/0x4:\&1 \
	-f 0x10000,0x5000/0x4:\&1 \
	-f 0x10000,0:\&3 \
	-f 0x3000/0x4,0x10000:\&1 \
	-f 0x5000/0x4,0x10000:\&1 \
	-f 0,0x10000:\&3 \
	\
	-f 0x4,0x4:\&3 \
	-f 0x4,0/0x1000:\&3 \
	-f 0x4,0:\&1 \
	-f 0/0x1000,0x4:\&3 \
	-f 0,0x4:\&1 \
	\
	-f 0/0x1000,0/0x1000:\&3 \
	-f 0x8000/0x6000,0x8000/0x6000:\&3 \
	-f 0,0:\&1 |
    { sam-header $mappings_to_reference.sam.gz; exec cat; } |
    tee >($ZIP >$mappings_clean_to_reference.sam.gz) |
    samtools view -Su - |
    samtools flagstat - >$mappings_clean_to_reference.stats
}
run_stage


#
# Stage 6: Extract reads for alu mapping
#
# Input: clean mappings to reference
# Output: reads to map to alus
#
STAGE_NUM=6
STAGE_NAME="extract reads for alu mapping"
reads_for_alu_mapping=$prefix.reads.for_alu_mapping
INPUT_FILES="$mappings_clean_to_reference.sam.gz"
OUTPUT_FILES="$reads_for_alu_mapping.fq.gz $reads_for_alu_mapping.stats"
STATS_FILE=
stage_command() {
    $PV $mappings_clean_to_reference.sam.gz |
    sam-body |
    reset-mqv-when-discordant 2>/dev/null |
    sam-to-fq-trimmed |
    fq-remove-short-reads |
    tee >($ZIP >$reads_for_alu_mapping.fq.gz) |
    fq-stats >$reads_for_alu_mapping.stats
}
run_stage


#
# Stage 7: Map to alus
#
# Input: reads to map to alus
# Output: mappings to alus
#
STAGE_NUM=7
STAGE_NAME="mapping to alus"
mappings_to_alus=$prefix.map.to_alus
gmapper_exec="gmapper-ls"
gmapper_options="-N $NCPU -n 1 --progress 10000 --qv-offset 33 -o 100 --local --no-mapping-qualities -r 180"
INPUT_FILES="$reads_for_alu_mapping.fq.gz"
OUTPUT_FILES="$mappings_to_alus.sam.gz"
STATS_FILE="$mappings_to_alus.stats"
stage_command() {
    $gmapper_exec $gmapper_options $reads_for_alu_mapping.fq.gz $ALU_NO_POLYA_FA \
	2>$mappings_to_alus.log |
    $ZIP >$mappings_to_alus.sam.gz
}
stage_stats_command() {
    echo -n "Reads mapped to alus: "
    sam-body $mappings_to_alus.sam.gz | cut -f 1 | cut -d ':' -f 1,2 | uniq | wc -l
    echo -n "Clones mapped to alus: "
    sam-body $mappings_to_alus.sam.gz | cut -f 1 | cut -d ':' -f 1 | uniq | wc -l
}
run_stage


#
# Stage 8: Get regions
#
# Input: clean mappings to reference, mappings to alus
# Output: regions with potential insertions
#
STAGE_NUM=8
STAGE_NAME="find potential insertions"
raw_calls=$prefix.calls.raw
INPUT_FILES="$mappings_clean_to_reference.sam.gz $mappings_to_alus.sam.gz"
OUTPUT_FILES="$raw_calls.bed"
STATS_FILE=
stage_command() {
    get-regions -l $pairing_file -N $NCPU \
	$REF_FA $mappings_clean_to_reference.sam.gz \
	$ALU_ALL_FA $mappings_to_alus.sam.gz \
	2> >($ZIP >$raw_calls.log.gz) |
    relabel-family |
    sed 's/Alu//g; s/Null://' >$raw_calls.bed
}
run_stage


#
# Stage 9: Find novel insertions
#
# Input: detected insertions, known insertions
# Output: novel insertions
#
STAGE_NUM=9
STAGE_NAME="get novel insertions"
novel_calls=$prefix.calls.basic-filters
INPUT_FILES="$raw_calls.bed"
OUTPUT_FILES="$novel_calls.bed"
STATS_FILE=
stage_command() {
    filter-ref-alu-bp $ALUS_BED $raw_calls.bed |
    filter-length 150 |
    filter-support 10 |
    filter-weak-null 200 |
    filter-ci-length 1100 >$novel_calls.bed
}
run_stage
