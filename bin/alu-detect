#!/bin/bash
. lib.alu-detect.sh
set -eEux -o pipefail

[ ! -e /proc/$$/fd/3 ] || crash "fd 3 needs to be closed"


find_my_name_and_dir "${BASH_SOURCE[0]}"
BASE_DIR=$(dirname $MY_DIR)
make_note "$MY_NAME v$(cat $BASE_DIR/VERSION) (git:$($BASE_DIR/get_git_version)) installed in $MY_DIR"

NGS_NAME=$1
REF_NAME=$2
PREFIX=$NGS_NAME.$REF_NAME

GLOBAL_SETTINGS=$BASE_DIR/settings/global
. "$GLOBAL_SETTINGS" || crash "missing global settings file: $GLOBAL_SETTINGS"
REF_SETTINGS=$BASE_DIR/settings/ref.$REF_NAME
. "$REF_SETTINGS" 2>/dev/null || crash "missing reference settings file: $REF_SETTINGS"


#
# don't trust the user; check most settings
#
(which python >/dev/null 2>&1 && [ "$(python --version 2>&1 | cut -d '.' -f 2)" -ge 6 ]) \
    || crash "python2.6+ not found"
which samtools >/dev/null 2>&1 || crash "samtools not found"
which intersectBed >/dev/null 2>&1 || crash "intersectBed not found"
which bowtie2 >/dev/null 2>&1 || crash "bowtie2 not found"
which gmapper-ls >/dev/null 2>&1 || crash "gmapper not found"
[[ "$AWKPATH" =~ $BASE_DIR/bin ]] || crash "AWKPATH not set properly"
[ -r "$ALU_ALL_FA" ] || crash "Alu consensus sequences missing from: $ALU_ALL_FA"
[ -r "$ALU_NO_POLYA_FA" ] || crash "masked Alu consensus sequences missing from: $ALU_NO_POLYA_FA"

[ -r "$REF_FA" ] || crash "reference fasta file missing: $REF_FA"
[ -r "$CHROMINFO" ] || crash "chrominfo file missing: $CHROMINFO"
for suffix in .1.bt2 .2.bt2 .3.bt2 .4.bt2 .rev.1.bt2 .rev.2.bt2; do
    [ -r "$BOWTIE2_INDEX$suffix" ] || crash "bowtie2 index file missing: $BOWTIE2_INDEX$suffix"
done
[ -r "$ALUS_BED" ] || crash "reference alu annotations missing: $ALUS_BED"


make_note "using NCPU=$NCPU"
START_STAGE=${START_STAGE:-0}
END_STAGE=${END_STAGE:-100}
make_note "using START_STAGE=$START_STAGE and END_STAGE=$END_STAGE"


if [ $START_STAGE -lt 3 ]; then
    # need original mappings
    ORIG_UNPAIRED_READS=${ORIG_UNPAIRED_READS:-}
    ORIG_PAIRED_READS=${ORIG_PAIRED_READS:-}
    ORIG_READS_1=${ORIG_READS_1:-}
    ORIG_READS_2=${ORIG_READS_2:-}
    ORIG_READ_GROUPS=${ORIG_READ_GROUPS:-}
    ORIG_MAPPINGS=${ORIG_MAPPINGS:-}
    make_note "using unpaired reads file(s): [$ORIG_UNPAIRED_READS]"
    make_note "using paired reads file(s): [$ORIG_PAIRED_READS]"
    make_note "using reads_1 file(s): [$ORIG_READS_1]"
    make_note "using reads_2 file(s): [$ORIG_READS_2]"
    make_note "using reads group(s): [$ORIG_READ_GROUPS]"
    make_note "using mapping file(s): [$ORIG_MAPPINGS]"

    orig_unpaired_reads=($(echo $ORIG_UNPAIRED_READS))
    orig_paired_reads=($(echo $ORIG_PAIRED_READS))
    orig_reads_1=($(echo $ORIG_READS_1))
    orig_reads_2=($(echo $ORIG_READS_2))
    orig_read_groups=($(echo $ORIG_READ_GROUPS))
    orig_mappings=($(echo $ORIG_MAPPINGS))

    have_unpaired_reads=0
    if [[ ${#orig_unpaired_reads[@]} -ne 0 &&
	${#orig_unpaired_reads[@]} -eq ${#orig_read_groups[@]} ]]; then
	have_unpaired_reads=1
	make_note "found unpaired reads"
    fi

    have_paired_reads_single=0
    if [[ ${#orig_paired_reads[@]} -ne 0 &&
	${#orig_paired_reads[@]} -eq ${#orig_read_groups[@]} ]]; then
	have_paired_reads_single=1
	make_note "found paired reads in single file(s)"
    fi

    have_paired_reads_double=0
    if [[ ${#orig_reads_1[@]} -ne 0 &&
	${#orig_reads_1[@]} -eq ${#orig_read_groups[@]} &&
	${#orig_reads_2[@]} -eq ${#orig_read_groups[@]} ]]; then
	have_paired_reads_double=1
	make_note "found paired reads in double file(s)"
    fi

    have_mappings=0
    if [ ${#orig_mappings[@]} -ne 0 ]; then
	have_mappings=1
	make_note "found mappings"
    fi

    let n_inputs=$have_unpaired_reads+$have_paired_reads_single+$have_paired_reads_double+$have_mappings 1
    [ $n_inputs -ge 1 ] || crash "No inputs specified"
    [ $n_inputs -le 1 ] || crash "Too many inputs specified"

    if [ $have_mappings = 0 ]; then
	make_note "given reads only; need to map them"
	INPUT_PHRED=${INPUT_PHRED:-}
	[ ! $INPUT_PHRED ] || make_note "using global input PHRED: [$INPUT_PHRED]"
	rm -f $PREFIX.initial.pairing

	i=0
	while [ $i -lt ${#orig_read_groups[@]} ]; do
	    export RGID=${orig_read_groups[$i]}
	    rg_pairing=$PREFIX.pairing.$RGID.$i
	    rg_mapping=$PREFIX.map.$RGID.$i

	    if [ $have_unpaired_reads = 1 ]; then

		if [ $INPUT_PHRED ]; then
		    input_phred_rg=$INPUT_PHRED
		else
		    input_phred_rg=$(fq-detect-phred ${orig_unpaired_reads[$i]})
		    make_note "detected PHRED+$input_phred_rg for read group $RGID"
		fi

		STAGE_NUM=0.$i
		STAGE_NAME="original mappings for unpaired read group: $RGID"
		INPUT_FILES="${orig_unpaired_reads[$i]}"
		OUTPUT_FILES="$rg_mapping.sam.gz"
		STATS_FILE=
		stage_command() {
		    pv ${orig_unpaired_reads[$i]} | zc \
			| bowtie2 -x $BOWTIE2_INDEX \
			  -U - \
			  --phred$input_phred_rg -p $NCPU --rg-id $RGID 2>$rg_mapping.log \
			| $ZIP >$rg_mapping.sam.gz
		}
		run_stage

	    elif [ $have_paired_reads_single = 1 ]; then

                if [ $INPUT_PHRED ]; then
                    input_phred_rg=$INPUT_PHRED
                else
                    input_phred_rg=$(fq-detect-phred ${orig_paired_reads[$i]})
		    make_note "detected PHRED+$input_phred_rg for read group $RGID"
                fi

		STAGE_NUM=0.$i.1
		STAGE_NAME="detect pairing for paired read group: $RGID"
		INPUT_FILES="${orig_paired_reads[$i]}"
		OUTPUT_FILES="$rg_pairing"
		STATS_FILE=
		stage_command() {
		    INPUT_PHRED=$input_phred_rg fq-detect-pairing ${orig_paired_reads[$i]} | cut -f 3 >$rg_pairing
		}
		run_stage

		STAGE_NUM=0.$i.2
		STAGE_NAME="mapping for paired read group: $RGID"
		INPUT_FILES="${orig_paired_reads[$i]} $rg_pairing"
		OUTPUT_FILES="$rg_mapping.sam.gz"
		STATS_FILE=$rg_mapping.stats
		stage_command() {
		    $PV ${orig_paired_reads[$i]} | zc | split-file 4:- 4:/dev/null \
			| bowtie2 -x $BOWTIE2_INDEX \
			  -1 - -2 <(zc ${orig_paired_reads[$i]} | split-file 4:/dev/null 4:-) \
			  $(get-bowtie-pairing -p $(cat $rg_pairing)) \
			  --phred$input_phred_rg -p $NCPU --rg-id $RGID 2>$rg_mapping.log \
			| $ZIP >$rg_mapping.sam.gz
		}
		stage_stats_command() {
		    $PV $rg_mapping.sam.gz | samtools view -Su - | samtools flagstat -
		}
		run_stage

	    else

                if [ $INPUT_PHRED ]; then
                    input_phred_rg=$INPUT_PHRED
                else
                    input_phred_rg=$(fq-detect-phred ${orig_reads_1[$i]})
		    make_note "detected PHRED+$input_phred_rg for read group $RGID"
                fi

		STAGE_NUM=0.$i.1
		STAGE_NAME="detect pairing for paired read group: $RGID"
		INPUT_FILES="${orig_reads_1[$i]} ${orig_reads_2[$i]}"
		OUTPUT_FILES="$rg_pairing"
		STATS_FILE=
		stage_command() {
		    INPUT_PHRED=$input_phred_rg fq-detect-pairing ${orig_reads_1[$i]} ${orig_reads_2[$i]} | cut -f 3 >$rg_pairing
		}
		run_stage

		STAGE_NUM=0.$i.2
		STAGE_NAME="mapping for paired read group: $RGID"
		INPUT_FILES="${orig_reads_1[$i]} ${orig_reads_2[$i]} $rg_pairing"
		OUTPUT_FILES="$rg_mapping.sam.gz"
		STATS_FILE=$rg_mapping.stats
		stage_command() {
		    $PV ${orig_reads_1[$i]} | zc \
			| bowtie2 -x $BOWTIE2_INDEX \
			  -1 - -2 <(zc ${orig_reads_2[$i]}) \
			  $(get-bowtie-pairing -p $(cat $rg_pairing)) \
			  --phred$input_phred_rg -p $NCPU --rg-id $RGID 2>$rg_mapping.log \
			| $ZIP >$rg_mapping.sam.gz
		}
		stage_stats_command() {
		    $PV $rg_mapping.sam.gz | samtools view -Su - | samtools flagstat -
		}
		run_stage

	    fi

	    ORIG_MAPPINGS="$ORIG_MAPPINGS $rg_mapping.sam.gz"
	    let i+=1
	done
	orig_mappings=($(echo $ORIG_MAPPINGS))
	orig_read_groups=()
    fi
else
    ORIG_MAPPINGS=
fi


get_orig_mappings() {
    file=${orig_mappings[$1]}
    [ -r $file ] || crash "$file: file not found"
    rg=${orig_read_groups[$1]:-}
    command="$PV $file"
    if (set +o pipefail; zc $file | head -n 1 | cut -c -3 | grep -q "BAM"); then
	command="$command | samtools view -h -"
    elif (set +o pipefail; file $file | grep -q gzip); then
	command="$command | $UNZIP"
    fi
    if [ ${add_dummy_pairs:-} ]; then
	command="$command | add-dummy-pairs"
    fi
    if (set +o pipefail; zc $file | head -n 1 | grep -q "coordinate") || [ "${RSORT:-}" ]; then
	command="$command | sam-rsort"
    fi
    make_note "command to get mappings: $command"
#    (set +e +o pipefail; eval $command | add-default-rg $rg || true)
    eval $command | add-default-rg $rg
}


#
# Stage 1: detect pairing information in mappings
#
STAGE_NUM=1
STAGE_NAME="detect pairing information"
PAIRING_FILE=$PREFIX.pairing
INPUT_FILES="$ORIG_MAPPINGS"
OUTPUT_FILES="$PAIRING_FILE"
STATS_FILE=
stage_command() {
    rm -f $PAIRING_FILE.tmp
    i=0
    while [ $i -lt ${#orig_mappings[@]} ]; do
	no_sigpipe get_orig_mappings $i | detect-pairing -f >>$PAIRING_FILE.tmp
	let i+=1
    done
    sed 's/\(^.*stddev=\([0-9]*\),.*$\)/\1\t\2/' <$PAIRING_FILE.tmp \
	| sort -s -k 1,1 -k 4,4n \
	| cut -f 1-3 \
	| tawk 'BEGIN{last=""} {if ($1!=last) print; last=$1}' >$PAIRING_FILE.tmp.uniq
    tawk -v n=$(wc -l <$PAIRING_FILE.tmp.uniq) \
	'{$2=NR-1; while (length($2)<length(n-1)) $2="0" $2; print}' \
	<$PAIRING_FILE.tmp.uniq >$PAIRING_FILE
}
run_stage

grep -q "paired=" $PAIRING_FILE || crash "could not determine pairing information"


#
# Stage 2: Extract discordant reads and rename them
#
# Input: mappings, reads
# Output: reads unmapped and reads mapped unpaired
#
STAGE_NUM=2
STAGE_NAME="extract discordant reads"
READS_DISCORDANT=$PREFIX.reads.discordant
READS_TO_REMAP=$PREFIX.reads.to_remap
INPUT_FILES="$ORIG_MAPPINGS"
OUTPUT_FILES="$READS_TO_REMAP.fq.gz $READS_TO_REMAP.stats"
STATS_FILE=
stage_command () {
    i=0
    while [ $i -lt ${#orig_mappings[@]} ]; do
	add_dummy_pairs=1 get_orig_mappings $i \
	    | add-extra-sam-flags -N 4 -l $PAIRING_FILE \
	    | filter-mappings -N 4 -l $PAIRING_FILE 3>/dev/null \
		-f 0x10000,0x10000:\&3 \
		\
		-f 0x10000,0/0x6004:\&3 \
		-f 0x10000,0:\&1 \
		-f 0/0x6004,0x10000:\&3 \
		-f 0,0x10000:\&1 \
		\
		-f 0x4,0:\&1 \
		-f 0,0x4:\&1 \
		-f 0/0x8000,0:\&1 \
		-f 0/0x6000,/0x6000:\&3 \
		-f 0,0:\&1 \
	    | sam-to-fq -s -l $PAIRING_FILE
	let i+=1
    done \
	| fq-trim-illumina-reads -v input_phred=33 \
        | fq-remove-short-paired-reads \
        | fq-rename-paired-reads-with-len \
	| tee >($ZIP >$READS_TO_REMAP.fq.gz) | fq-stats >$READS_TO_REMAP.stats
}
run_stage


#
# Stage 4: Progressive mapping
#
# Input: reads to remap
# Output: mappings to reference, possibly trimmed
#
STAGE_NUM=4
STAGE_NAME="progressive mapping to reference"
MAPPINGS_TO_REFERENCE=$PREFIX.map.to_reference
INPUT_FILES="$READS_TO_REMAP.fq.gz"
OUTPUT_FILES="$MAPPINGS_TO_REFERENCE.sam.gz $MAPPINGS_TO_REFERENCE.stats"
STATS_FILE=
stage_command() {
    progressive-mapping $READS_TO_REMAP.fq.gz \
	| tee >($ZIP >$MAPPINGS_TO_REFERENCE.sam.gz) | samtools view -Su - | samtools flagstat - >$MAPPINGS_TO_REFERENCE.stats
}
run_stage


#
# Stage 5: Clean reference mappings
#
# Input: mappings to reference
# Output: same, removing clones which are mapped as pairs
#
STAGE_NUM=5
STAGE_NAME="clean up reference mappings: remove unpaired and paired well; add orig reads and quals"
MAPPINGS_CLEAN_TO_REFERENCE=$PREFIX.map.clean_to_reference
INPUT_FILES="$MAPPINGS_TO_REFERENCE.sam.gz"
OUTPUT_FILES="$MAPPINGS_CLEAN_TO_REFERENCE.sam.gz $MAPPINGS_CLEAN_TO_REFERENCE.stats"
STATS_FILE=
stage_command() {
    $PV $MAPPINGS_TO_REFERENCE.sam.gz \
	| add-extra-sam-flags -N 4 -l $PAIRING_FILE -P \
	| filter-mappings -N 4 -l $PAIRING_FILE -P 3>/dev/null \
	    -f 0x10000,0x10000:\&3 \
	    -f 0x10000,0x3000/0x4:\&1 \
	    -f 0x10000,0x5000/0x4:\&1 \
	    -f 0x10000,0:\&3 \
	    -f 0x3000/0x4,0x10000:\&1 \
	    -f 0x5000/0x4,0x10000:\&1 \
	    -f 0,0x10000:\&3 \
	    \
	    -f 0x4,0x4:\&3 \
	    -f 0x4,0/0x1000:\&3 \
	    -f 0x4,0:\&1 \
	    -f 0/0x1000,0x4:\&3 \
	    -f 0,0x4:\&1 \
	    \
	    -f 0/0x1000,0/0x1000:\&3 \
	    -f 0x8000/0x6000,0x8000/0x6000:\&3 \
	    -f 0,0:\&1 \
	| { sam-header $MAPPINGS_TO_REFERENCE.sam.gz; cat; } \
	| tee >($ZIP >$MAPPINGS_CLEAN_TO_REFERENCE.sam.gz) | samtools view -Su - | samtools flagstat - >$MAPPINGS_CLEAN_TO_REFERENCE.stats
}
run_stage


#
# Stage 6: Extract reads for alu mapping
#
# Input: clean mappings to reference
# Output: reads to map to alus
#
STAGE_NUM=6
STAGE_NAME="extract reads for alu mapping"
READS_FOR_ALU_MAPPING=$PREFIX.reads.for_alu_mapping
INPUT_FILES="$MAPPINGS_CLEAN_TO_REFERENCE.sam.gz"
OUTPUT_FILES="$READS_FOR_ALU_MAPPING.fq.gz $READS_FOR_ALU_MAPPING.stats"
STATS_FILE=
stage_command() {
    $PV $MAPPINGS_CLEAN_TO_REFERENCE.sam.gz \
	| sam-body \
	| reset-mqv-when-discordant 2>/dev/null \
	| sam-to-fq-trimmed \
	| fq-remove-short-reads \
	| tee >($ZIP >$READS_FOR_ALU_MAPPING.fq.gz) | fq-stats >$READS_FOR_ALU_MAPPING.stats
}
run_stage


#
# Stage 7: Map to alus
#
# Input: reads to map to alus
# Output: mappings to alus
#
STAGE_NUM=7
STAGE_NAME="mapping to alus"
MAPPINGS_TO_ALUS=$PREFIX.map.to_alus
GMAPPER_EXEC="gmapper-ls"
GMAPPER_OPTIONS="-N $NCPU -n 1 --progress 10000 --qv-offset 33 -o 100 --local --no-mapping-qualities -r 180"
INPUT_FILES="$READS_FOR_ALU_MAPPING.fq.gz"
OUTPUT_FILES="$MAPPINGS_TO_ALUS.sam.gz"
STATS_FILE="$MAPPINGS_TO_ALUS.stats"
stage_command() {
    $GMAPPER_EXEC $GMAPPER_OPTIONS $READS_FOR_ALU_MAPPING.fq.gz $ALU_NO_POLYA_FA \
	2>$MAPPINGS_TO_ALUS.log | $ZIP >$MAPPINGS_TO_ALUS.sam.gz
}
stage_stats_command() {
    echo -n "Reads mapped to alus: "
    sam-body $MAPPINGS_TO_ALUS.sam.gz | cut -f 1 | cut -d ':' -f 1,2 | uniq | wc -l
    echo -n "Clones mapped to alus: "
    sam-body $MAPPINGS_TO_ALUS.sam.gz | cut -f 1 | cut -d ':' -f 1 | uniq | wc -l
}
run_stage


#
# Stage 8: Get regions
#
# Input: clean mappings to reference, mappings to alus
# Output: regions with potential insertions
#
STAGE_NUM=8
STAGE_NAME="find potential insertions"
RAW_CALLS=$PREFIX.calls.raw
INPUT_FILES="$MAPPINGS_CLEAN_TO_REFERENCE.sam.gz $MAPPINGS_TO_ALUS.sam.gz"
OUTPUT_FILES="$RAW_CALLS.bed"
STATS_FILE=
stage_command() {
    get-regions -l $PAIRING_FILE -N $NCPU \
	$REF_FA $MAPPINGS_CLEAN_TO_REFERENCE.sam.gz \
	$ALU_ALL_FA $MAPPINGS_TO_ALUS.sam.gz \
	2> >($ZIP >$RAW_CALLS.log.gz) \
	| relabel-family | sed 's/Alu//g; s/Null://' >$RAW_CALLS.bed
}
run_stage


#
# Stage 9: Find novel insertions
#
# Input: detected insertions, known insertions
# Output: novel insertions
#
STAGE_NUM=9
STAGE_NAME="get novel insertions"
NOVEL=$PREFIX.calls.basic-filters
INPUT_FILES="$RAW_CALLS.bed"
OUTPUT_FILES="$NOVEL.bed"
STATS_FILE=
stage_command() {
    filter-ref-alu-bp $ALUS_BED $RAW_CALLS.bed \
	| filter-length 150 \
	| filter-support 10 \
	| filter-weak-null 200 \
	| filter-ci-length 1100 \
	>$NOVEL.bed
}
run_stage
