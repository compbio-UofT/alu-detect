#!/bin/bash

. $(which my-lib.sh)
set -ex

ask_continue() {
    if [ "${CONF:-}" = a ] ; then return ; fi
    read -p "continue? (y/a/s/N) " CONF
    if [ "$CONF" != y -a "$CONF" != a -a "$CONF" != s ] ; then exit ; fi
    if [ "$CONF" = s ] ; then return 1 ; fi
}

run_stage() {
    echo "--------------------" >&2
    make_note "Stage $STAGE_NUM: $STAGE_NAME"

    if [ "$STAGE_NUM" -lt "$START_STAGE" ] ; then
	make_note "skipping"
	return
    elif [ "$STAGE_NUM" -gt "$END_STAGE" ] ; then
	make_note "done because END_STAGE=$END_STAGE"
	exit
    fi

    for f in $INPUT_FILES ; do
	if [ ! -r $f ] ; then crash "$f missing" ; fi
    done

    NEED_TO_RUN=0
    for f in $OUTPUT_FILES ; do
	if [ ! -r "$f" ] ; then
	    make_note "$f does not exist"
	    NEED_TO_RUN=1
	    break
	fi
    done
    if [ $NEED_TO_RUN = 0 ] ; then
	for f in $OUTPUT_FILES ; do
	    for g in $INPUT_FILES ; do
		if [ "$g" -nt "$f" ] ; then
		    make_note "$g is newer than $f"
		    NEED_TO_RUN=1
		    break
		fi
	    done
	    if [ $NEED_TO_RUN = 1 ] ; then break ; fi
	done
    fi
    if [ $NEED_TO_RUN = 0 ] ; then
	make_note "$OUTPUT_FILES up to date"
    else
	make_note "need to run"
	typeset -f stage_command >&2
	if ask_continue ; then
	    make_note "starting"
	    stage_command || { rm $OUTPUT_FILES ; crash "failed" ; }
	    make_note "done"
	else
	    make_note "skipping"
	fi
    fi

    if [ "$STATS_FILE" ] ; then
	NEED_TO_RUN=0
	if [ ! -r "$STATS_FILE" ] ; then
	    make_note "$STATS_FILE does not exist"
	    NEED_TO_RUN=1
	fi
	if [ $NEED_TO_RUN = 0 ] ; then
	    for g in $OUTPUT_FILES ; do
		if [ "$g" -nt "$STATS_FILE" ] ; then
		    make_note "$g is newer than $STATS_FILE"
		    NEED_TO_RUN=1
		    break
		fi
	    done
	fi
	if [ $NEED_TO_RUN = 0 ] ; then
	    make_note "using existing stats"
	else
	    make_note "collecting stats"
	    typeset -f stage_stats_command >&2
	    if ask_continue ; then
	    make_note "starting"
		stage_stats_command >$STATS_FILE || { rm $STATS_FILE ; crash "failed" ; }
		make_note "done"
	    else
		make_note "skipping"
	    fi
	fi
	cat $STATS_FILE >&2
    fi
}

NCPU=${NCPU:-2}
make_note "using NCPU=$NCPU"

if pv --version >/dev/null 2>/dev/null ; then
    PV="pv -f"
else
    PV=cat
fi

if pigz --version >/dev/null 2>/dev/null ; then
    ZIP="pigz -9 -p $NCPU"
else
    ZIP=gzip
fi

START_STAGE=${START_STAGE:-1}
END_STAGE=${END_STAGE:-100}
make_note "using START_STAGE=$START_STAGE and END_STAGE=$END_STAGE"


#[ $# -ne 3 ] && crash "use: $(basename $0) <reads.fq> <mappings.sam> <mappings.sort.bam>"
[ -z "$REF_FA" -o ! -r "$REF_FA" ] && crash "REF_FA undefined or incorrect"
[ -z "$BOWTIE2_INDEX" -o ! -r "${BOWTIE2_INDEX}.1.bt2" ] && crash "BOWTIE2_INDEX undefined or incorrect"
[ -z "$ALU_NO_POLYA_FA" ] && crash "ALU_NO_POLYA_FA undefined"
[ -z "$ALU_ALL_FA" ] && crash "ALU_ALL_FA undefined"
[ -z "$ALUS_BED" ] && crash "ALUS_BED undefined"
[ -z "$AWKPATH" ] && crash "AWKPATH undefined"
[ -z "$PYTHONPATH" ] && crash "PYTHONPATH undefined"

find_my_name_and_dir "${BASH_SOURCE[0]}"
PATH=$PATH:$MY_DIR


export RGID=${RGID:-00}
if [ -n "$(echo "$RGID" | grep -P "[^\d]")" ] ; then
    crash "RGID must be an integer"
fi

ORIG_READS=${ORIG_READS:-}
ORIG_MAPPINGS_SAM=${ORIG_MAPPINGS_SAM:-}
ORIG_MAPPINGS_BAM=${ORIG_MAPPINGS_BAM:-}
ORIG_MAPPINGS_SORT_BAM=${ORIG_MAPPINGS_SORT_BAM:-}
make_note "using read group: [$RGID]"
make_note "using reads file: [$ORIG_READS]"
make_note "using mappings sam file: [$ORIG_MAPPINGS_SAM]"
make_note "using mappings bam file: [$ORIG_MAPPINGS_BAM]"
make_note "using sorted mappings file: [$ORIG_MAPPINGS_SORT_BAM]"

if [ "$ORIG_MAPPINGS_SAM" ] ; then
    get_orig_mappings() {
	$PV "$ORIG_MAPPINGS_SAM"
    }
elif [ "$ORIG_MAPPINGS_BAM" ] ; then
    get_orig_mappings() {
	$PV "$ORIG_MAPPINGS_BAM" | samtools view -h -
    }
elif [ "$ORIG_MAPPINGS_SORT_BAM" ] ; then
    get_orig_mappings() {
	$PV "$ORIG_MAPPINGS_SORT_BAM" | samtools view -h - | sam-rsort
    }
else
    get_orig_mappings() {
	crash "original mappings not available!"
    }
fi

INPUT_PHRED=${INPUT_PHRED:-0}
make_note "using input phred: [$INPUT_PHRED]"


#
# Stage 1: detect pairing information in mappings
#
STAGE_NUM=1
STAGE_NAME="detect pairing information"
PAIRING_FILE=$RGID.pairing
INPUT_FILES="$ORIG_MAPPINGS_SAM $ORIG_MAPPINGS_BAM"
OUTPUT_FILES="$PAIRING_FILE"
STATS_FILE=
stage_command() {
    get_orig_mappings | detect-pairing >"$PAIRING_FILE"
}
run_stage

export PAIRING="$(cat $PAIRING_FILE)"
if [[ ! "$PAIRING" =~ "paired=" ]] ; then
    crash "could not determine pairing information"
fi
make_note "using PAIRING=\"$PAIRING\""


#
# Stage 2: Extract discordant reads
#
# Input: mappings, reads
# Output: reads unmapped and reads mapped unpaired
#
STAGE_NUM=2
STAGE_NAME="extract discordant reads"
READS_DISCORDANT=$RGID.reads.discordant
INPUT_FILES="$ORIG_MAPPINGS_SAM $ORIG_MAPPINGS_BAM"
#INPUT_FILES="$ORIG_READS $ORIG_MAPPINGS"
OUTPUT_FILES="$READS_DISCORDANT.fq.gz"
STATS_FILE="$READS_DISCORDANT.stats"
stage_command () {
    get_orig_mappings \
	| add-extra-sam-flags -p $PAIRING \
	| {
	      if [[ "$PAIRING" =~ "paired=1" ]] ; then
		  filter-mappings -p $PAIRING \
		      -f 0/0x8000,0:\&1 \
		      -f 0x2000,0:\&1 \
		      -f 0x4000,0:\&1 \
		      -f 0,0x2000:\&1 \
		      -f 0,0x4000:\&1
	      else
		  filter-mappings -p $PAIRING \
		      -f 0x4:\&1 \
		      -f 0x2000:\&1 \
		      -f 0x4000:\&1
	      fi
          } \
	| sam-to-fq -p $PAIRING \
	| $ZIP >$READS_DISCORDANT.fq.gz
}
stage_stats_command() {
    $PV $READS_DISCORDANT.fq.gz | fq-stats
}
run_stage


#
# Stage 3: Trim & rename reads
#
# Input: reads unmapped, reads mapped unpaired
# Output: reads to remap
#
STAGE_NUM=3
STAGE_NAME="read renaming"
READS_TO_REMAP=$RGID.reads.to_remap
INPUT_FILES="$READS_DISCORDANT.fq.gz"
OUTPUT_FILES="$READS_TO_REMAP.fq.gz"
STATS_FILE="$READS_TO_REMAP.stats"
stage_command() {
    $PV $READS_DISCORDANT.fq.gz \
	| zc \
	| fq-trim-illumina-reads -v input_phred="$INPUT_PHRED" \
	| {
	      if [[ "$PAIRING" =~ "paired=1" ]] ; then
		  fq-remove-short-paired-reads 2>/dev/null \
		      | fq-rename-paired-reads-with-len -v g="$RGID"
	      else
		  fq-remove-short-reads 2>/dev/null \
		      | fq-rename-unpaired-reads-with-len -v g="$RGID"
	      fi
	  } \
	| $ZIP >$READS_TO_REMAP.fq.gz
}
stage_stats_command() {
    $PV $READS_TO_REMAP.fq.gz | fq-stats
}
run_stage


#
# Stage 4: Progressive mapping
#
# Input: reads to remap
# Output: mappings to reference, possibly trimmed
#
STAGE_NUM=4
STAGE_NAME="progressive mapping to reference"
MAPPINGS_TO_REFERENCE=$RGID.map.to_reference
INPUT_FILES="$READS_TO_REMAP.fq.gz"
OUTPUT_FILES="$MAPPINGS_TO_REFERENCE.sam.gz"
STATS_FILE="$MAPPINGS_TO_REFERENCE.stats"
stage_command() {
    progressive-mapping $READS_TO_REMAP.fq.gz | $ZIP >$MAPPINGS_TO_REFERENCE.sam.gz
}
stage_stats_command() {
    $PV $MAPPINGS_TO_REFERENCE.sam.gz | samtools view -Su - | samtools flagstat -
}
run_stage


#
# Stage 5: Clean reference mappings
#
# Input: mappings to reference
# Output: same, removing clones which are mapped as pairs
#
STAGE_NUM=5
STAGE_NAME="clean up reference mappings: remove unpaired and paired well; add orig reads and quals"
MAPPINGS_CLEAN_TO_REFERENCE=$RGID.map.clean_to_reference
INPUT_FILES="$MAPPINGS_TO_REFERENCE.sam.gz"
OUTPUT_FILES="$MAPPINGS_CLEAN_TO_REFERENCE.sam.gz"
STATS_FILE="$MAPPINGS_CLEAN_TO_REFERENCE.stats"
stage_command() {
    $PV $MAPPINGS_TO_REFERENCE.sam.gz \
	| clean-mappings 3>/dev/null \
	| $ZIP >$MAPPINGS_CLEAN_TO_REFERENCE.sam.gz
}
stage_stats_command() {
    $PV $MAPPINGS_CLEAN_TO_REFERENCE.sam.gz | samtools view -Su - | samtools flagstat -
}
run_stage


#
# Stage 6: Extract reads for alu mapping
#
# Input: clean mappings to reference
# Output: reads to map to alus
#
STAGE_NUM=6
STAGE_NAME="extract reads for alu mapping"
READS_FOR_ALU_MAPPING=$RGID.reads.for_alu_mapping
INPUT_FILES="$MAPPINGS_CLEAN_TO_REFERENCE.sam.gz"
OUTPUT_FILES="$READS_FOR_ALU_MAPPING.fq.gz"
STATS_FILE="$READS_FOR_ALU_MAPPING.stats"
stage_command() {
    $PV $MAPPINGS_CLEAN_TO_REFERENCE.sam.gz \
	| extract-reads-for-alu-mapping \
	| fq-remove-short-reads 2>/dev/null \
	| $ZIP >$READS_FOR_ALU_MAPPING.fq.gz
}
stage_stats_command() {
    $PV $READS_FOR_ALU_MAPPING.fq.gz | fq-stats
}
run_stage


#
# Stage 7: Map to alus
#
# Input: reads to map to alus
# Output: mappings to alus
#
STAGE_NUM=7
STAGE_NAME="mapping to alus"
MAPPINGS_TO_ALUS=$RGID.map.to_alus
GMAPPER_EXEC="gmapper-ls"
GMAPPER_OPTIONS="-N $NCPU -n 1 --progress 10000 --qv-offset 33 -o 100 --local --no-mapping-qualities -r 180"
INPUT_FILES="$READS_FOR_ALU_MAPPING.fq.gz"
OUTPUT_FILES="$MAPPINGS_TO_ALUS.sam.gz"
STATS_FILE="$MAPPINGS_TO_ALUS.stats"
stage_command() {
    $GMAPPER_EXEC $GMAPPER_OPTIONS $READS_FOR_ALU_MAPPING.fq.gz $ALU_NO_POLYA_FA \
	2>$MAPPINGS_TO_ALUS.log | $ZIP >$MAPPINGS_TO_ALUS.sam.gz
}
stage_stats_command() {
    echo -n "Reads mapped to alus: "
    sam-body $MAPPINGS_TO_ALUS.sam.gz | cut -f 1 | cut -d ':' -f 1,2 | uniq | wc -l
    echo -n "Clones mapped to alus: "
    sam-body $MAPPINGS_TO_ALUS.sam.gz | cut -f 1 | cut -d ':' -f 1 | uniq | wc -l
}
run_stage


#
# Stage 8: Get regions
#
# Input: clean mappings to reference, mappings to alus
# Output: regions with potential insertions
#
STAGE_NUM=8
STAGE_NAME="find potential insertions"
REGIONS=$RGID.regions
INPUT_FILES="$MAPPINGS_CLEAN_TO_REFERENCE.sam.gz $MAPPINGS_TO_ALUS.sam.gz"
OUTPUT_FILES="$REGIONS.bed"
STATS_FILE=
stage_command() {
    get-regions -p $PAIRING -N $NCPU \
	$REF_FA $MAPPINGS_CLEAN_TO_REFERENCE.sam.gz \
	$ALU_ALL_FA $MAPPINGS_TO_ALUS.sam.gz \
	2> >($ZIP >$REGIONS.log.gz) >$REGIONS.bed
}
run_stage


#
# Stage 9: Check reference allele
#
# Input: regions
# Output: regions with ref allele count
#
STAGE_NUM=9
STAGE_NAME="compute reference count"
REGIONS_REFCNT=$RGID.regions.refcnt
INPUT_FILES="$ORIG_MAPPINGS_SORT_BAM $REGIONS.bed"
OUTPUT_FILES="$REGIONS_REFCNT.bed"
STATS_FILE=
stage_command() {
    if [ -z "$ORIG_MAPPINGS_SORT_BAM" ] ; then
	sed 's/$/	./' <$REGIONS.bed >$REGIONS_REFCNT.bed
    else
	cat $REGIONS.bed | while read -r -a line ; do
	    RANGE="${line[0]}:$((${line[1]} + 1))-${line[2]}"
	    TSD_LEN=$((${line[11]} + 5))
	    if [ $TSD_LEN -lt 15 ] ; then
		TSD_LEN=15
	    fi
	    REF_ALLELE="$(samtools view "$ORIG_MAPPINGS_SORT_BAM" $RANGE \
		| check-reference-allele $RANGE -t $TSD_LEN 2>/dev/null)"
	    print_with_delim -d "\t" "${line[@]}" "$REF_ALLELE"
	done >$REGIONS_REFCNT.bed
    fi
}
run_stage


#
# Stage 10: Find novel insertions
#
# Input: detected insertions, known insertions
# Output: novel insertions
#
STAGE_NUM=10
STAGE_NAME="get novel insertions"
NOVEL=$RGID.novel
INPUT_FILES="$REGIONS_REFCNT.bed"
OUTPUT_FILES="$NOVEL.bed"
STATS_FILE=
stage_command() {
# awk 'BEGIN{OFS="\t"} {if($10=="0"){$2-=100};if($11=="0"){$3+=100};print}' <$REGIONS_REFCNT.bed
    filter-length 150 <$REGIONS_REFCNT.bed \
	| filter-support 5 \
	| filter-weak-null 200 >$NOVEL.bed
#    intersectBed -s -wa -v -a $REGIONS_REFCNT.bed \
#	-b <(extend-bed 0 $ALUS_BED) >$NOVEL.bed
#	| awk 'BEGIN{OFS="\t"} {if($10=="0"){$2+=100};if($11=="0"){$3-=100};print}'
}
run_stage
